# R-GSEA - GBM43

Set libpaths

```{r}
# Set libpaths
.libPaths(c("/raleighlab/data1/czou/gbm_perturb/gbm_perturb/renv/library/R-4.3/x86_64-pc-linux-gnu", .libPaths()))
```

Import libraries

```{r}
library(Seurat)
library(clusterProfiler)
library(org.Hs.eg.db)
library(knitr)
library(msigdbr)
library(fgsea)
library(dplyr)
library(data.table)
library(ggplot2)
library(grid)
library(ComplexHeatmap)
library(colorRamp2)
library(tidyr)
library(patchwork)
library(ggtree)
library(gridExtra)
library(ape)
library(RColorBrewer)
library(reactome.db)
library(annotables)
library(biomaRt)
```

Define a bunch of constants.

```{r}
INPUT_DIRS <- c("/raleighlab/data1/czou/gbm_perturb/gbm_perturb_gbm43_clean_outputs/deseq/noRTNormalized")
OUTPUT_DIR <- "/raleighlab/data1/czou/gbm_perturb/gbm_perturb_gbm43_explore_outputs/gsea"
PATH_TO_SEURAT_OBJECT <- "/raleighlab/data1/liuj/gbm_perturb/analysis/GBM43_1_malignant_only_annotated_20230817.Rds"
WORKING_DIR <- "/raleighlab/data1/czou/gbm_perturb/gbm_perturb_gbm43_explore_outputs/gsea/noRTNormalized"
```

## Massage the DESeq2 Output

Import the DESeq output

```{r}
data.list <- list()
for (dir in INPUT_DIRS) {
  file_names <- list.files(dir)
  for (i in file_names) {
    name <- gsub(".csv", "", i)
    df <- read.table(paste(dir, "/", i, sep = ""))
    data.list[[name]] <- df
  }
}
```

Remove the GRCh38- prefix from all human genes.

```{r}
data.list.symbols <- list()
for (name in names(data.list)) {
  deseq_table <- data.list[[name]]
  deseq_table$feature <- gsub("GRCh38-", "", deseq_table$feature)
  data.list.symbols[[name]] <- deseq_table
}
```

Prepare an ENSEMBL gene ID data list by converting using the `annotables` package.

```{r}
mapping.df <- annotables::grch38
missing.genes <- list()
data.list.ensembl <- list()
for (name in names(data.list.symbols)) {
  deseq_table <- data.list.symbols[[name]]
  mapping.df <- mapping.df[!duplicated(mapping.df$symbol), ]
  mapping.table <- mapping.df[mapping.df$symbol %in% deseq_table$feature, ]
  mapping.table <- as.data.frame(mapping.table)
  rownames(mapping.table) <- mapping.table$symbol
  deseq_table$ensembl <- mapping.table[deseq_table$feature, "ensgene"]
  deseq_table.missing <- deseq_table[is.na(deseq_table$ensembl), ]
  missing.genes[[name]] <- deseq_table.missing$feature
  data.list.ensembl[[name]] <- deseq_table[!is.na(deseq_table$ensembl), ]
}
```

## Run GSEA on HALLMARK DB

Get rid of anything that shows low expression:

```{r}
processed.deseq.tables <- list()
for (name in names(data.list.ensembl)) {
  deseq_table <- data.list.ensembl[[name]]
  deseq_table <- deseq_table[!is.na(deseq_table$pvalue), ]
  deseq_table <- deseq_table[!is.na(deseq_table$padj), ]
  processed.deseq.tables[[name]] <- deseq_table
}
data.list <- processed.deseq.tables
```

For each DESeq output, prepare an ordered gene set by LFC that we will use for gene set enrichment analysis. Note that we remove the GRCh38- prefix from all human genes and remove any genes that have an NA LFC. We also change from gene symbol to ENSEMBL gene ID and remove unmappable symbols, averaging out the LFCs for multiple symbols that map to the same ENSEMBL gene ID.

```{r}
ranked_gene_set_list <- list()
for (name in names(data.list)) {
  cat("Processing", name, "\n")
  
  deseq_table <- data.list[[name]]
  deseq_table$feature <- gsub("GRCh38-", "", deseq_table$feature)
  mapping <- mapIds(org.Hs.eg.db, keys = deseq_table$feature,
                      column = "ENSEMBL", keytype = "SYMBOL")
  deseq_table$ensembl <- unlist(mapping)
  deseq_table <- subset(deseq_table, !is.na(deseq_table$ensembl))
  deseq_table <- deseq_table[!is.na(deseq_table$log_fc), ]
  
  # Group by unique ensembl ID and average
  deseq_table <- deseq_table %>%
    group_by(ensembl) %>%
    summarize(log_fc = mean(log_fc))
  deseq_table <- deseq_table %>% mutate(rank = rank(log_fc,  ties.method = "random"))
  deseq_table <- deseq_table[order(-deseq_table$rank),] # Rank deterministically
  
  # Generate a ranked list
  gene_list <- deseq_table$log_fc
  gene_names <- deseq_table$ensembl
  names(gene_list) <- gene_names
  ranked_gene_set_list[[name]] <- gene_list
}
```

Run GSEA using msigdbr and fgsea

```{r}
msigdbr_df <- msigdbr(species = "Homo sapiens", category = "H")
msigdbr_list = split(x = msigdbr_df$ensembl_gene, f = msigdbr_df$gs_name)

set.seed(1) # required for deterministic performance
fgsea.output.list <- list()
for (name in names(ranked_gene_set_list)) {
  gsea_results <- fgsea(pathways = msigdbr_list, stats = ranked_gene_set_list[[name]],
                        maxSize = 500, eps = 0.0) # allow arbitrarily low p-values
  fgsea.output.list[[name]] <- gsea_results
}
saveRDS(fgsea.output.list, paste(WORKING_DIR, "fgsea_ensembl_ontology_list.rds", sep = "/"))
```

Run the same MSigDB hallmark with the GSEA package instead of using fgsea. Note that the underlying implementation should be the same.

```{r}
hallmark_term_to_gene <- msigdbr(species = "Homo sapiens", category = "H") %>% 
  dplyr::select(gs_name, ensembl_gene)
hallmark.msigdb.ontology.list <- list()
for (name in names(ranked_gene_set_list)) {
  gsea <- GSEA(ranked_gene_set_list[[name]], 
               TERM2GENE = hallmark_term_to_gene, pvalueCutoff = 1.0)
  hallmark.msigdb.ontology.list[[name]] <- gsea
}
saveRDS(hallmark.msigdb.ontology.list, file = paste(WORKING_DIR, "gsea_ensembl_ontology_list.rds", sep = "/"))
```

Plot out example results for PRKDC.

```{r}

plotEnrichment(msigdbr_list[["HALLMARK_KRAS_SIGNALING_DN"]],
               ranked_gene_set_list[["PRKDC_noRT_non-targeting_noRT"]]) + labs(title="Hallmark KRAS Signaling Downregulation")
```

```{r}
fgseaRes <- fgsea.output.list$`non-targeting_RT_non-targeting_noRT`
topPathwaysUp<- fgseaRes[fgseaRes$ES > 0, ][order(fgseaRes[fgseaRes$ES > 0, ]$NES, decreasing = TRUE)[1:10], "pathway"]
topPathwaysDown <- fgseaRes[fgseaRes$ES < 0, ][order(fgseaRes[fgseaRes$ES < 0, ]$NES)[1:10], "pathway"]
topPathways <- unlist(c(topPathwaysUp, rev(topPathwaysDown)))
pdf(file=paste(WORKING_DIR, "GSEA_top_10_ES_ntRT.pdf", sep = "/"),width = 8,height = 4)
plotGseaTable(msigdbr_list[topPathways], ranked_gene_set_list$`non-targeting_RT_non-targeting_noRT`, fgseaRes, gseaParam=0.5)
dev.off()
```

One of the questions that we're trying to answer is whether or not there's a concrete upregulation/downregulation when it comes to the non-targeting control in the presence of radiation, especially as compared to PRKDC (a particular gene we're interested in) and CENPT (a particularly strong phenotype gene according to our NMF plots). Let's take a look at what those plots look like:

```{r}
# Plot for non-targeting_RT
fgseaRes <- fgsea.output.list$`non-targeting_RT_non-targeting_noRT`
topPathwaysUp<- fgseaRes[fgseaRes$ES > 0, ][order(fgseaRes[fgseaRes$ES > 0, ]$NES, decreasing = TRUE)[1:10], "pathway"]
topPathwaysDown <- fgseaRes[fgseaRes$ES < 0, ][order(fgseaRes[fgseaRes$ES < 0, ]$NES)[1:10], "pathway"]
topPathways <- unlist(c(topPathwaysUp, rev(topPathwaysDown)))
plot_grob <- plotGseaTable(msigdbr_list[topPathways], ranked_gene_set_list$`non-targeting_RT_non-targeting_noRT`, fgseaRes, gseaParam=0.5) 
grid.newpage()
grid.draw(plot_grob)
grid.text("Non-targeting RT vs. non-targeting noRT, top 10 pathways by pos/neg NES", x = unit(0, "npc"), y = unit(1, "npc"), gp = gpar(fontsize = 10))
```

```{r}
# Plot for PRKDC_RT and PRKDC-noRT
print("Here's RT")
fgseaRes <- fgsea.output.list$`PRKDC_RT_non-targeting_noRT`
topPathwaysUp<- fgseaRes[fgseaRes$ES > 0, ][order(fgseaRes[fgseaRes$ES > 0, ]$NES, decreasing = TRUE)[1:10], "pathway"]
topPathwaysDown <- fgseaRes[fgseaRes$ES < 0, ][order(fgseaRes[fgseaRes$ES < 0, ]$NES)[1:10], "pathway"]
topPathways <- unlist(c(topPathwaysUp, rev(topPathwaysDown)))
plotGseaTable(msigdbr_list[topPathways], ranked_gene_set_list$`PRKDC_RT_non-targeting_noRT`, fgseaRes, gseaParam=0.5)

print("Here's noRT")
fgseaRes <- fgsea.output.list$`PRKDC_noRT_non-targeting_noRT`
topPathwaysUp<- fgseaRes[fgseaRes$ES > 0, ][order(fgseaRes[fgseaRes$ES > 0, ]$NES, decreasing = TRUE)[1:10], "pathway"]
topPathwaysDown <- fgseaRes[fgseaRes$ES < 0, ][order(fgseaRes[fgseaRes$ES < 0, ]$NES)[1:10], "pathway"]
topPathways <- unlist(c(topPathwaysUp, rev(topPathwaysDown)))
plotGseaTable(msigdbr_list[topPathways], ranked_gene_set_list$`PRKDC_noRT_non-targeting_noRT`, fgseaRes, gseaParam=0.5)
```

For CENPT, note that we rank by pure enrichment score because there are some sketchy p-values that make it not possible to calculate an NES. It's interesting to note that when it comes to CENPT, there's very few differences between what gene sets are enriched under RT conditions and not.

```{r}
# Plot for CENPT_RT and CENPT_noRT
print("Here's RT")
fgseaRes <- fgsea.output.list$`CENPT_RT_non-targeting_noRT`
topPathwaysUp<- fgseaRes[fgseaRes$ES > 0, ][order(fgseaRes[fgseaRes$ES > 0, ]$ES, decreasing = TRUE)[1:10], "pathway"]
topPathwaysDown <- fgseaRes[fgseaRes$ES < 0, ][order(fgseaRes[fgseaRes$ES < 0, ]$ES)[1:10], "pathway"]
topPathways <- unlist(c(topPathwaysUp, rev(topPathwaysDown)))
plotGseaTable(msigdbr_list[topPathways], ranked_gene_set_list$`CENPT_RT_non-targeting_noRT`, fgseaRes, gseaParam=0.5)

print("Here's noRT")
fgseaRes <- fgsea.output.list$`CENPT_noRT_non-targeting_noRT`
topPathwaysUp<- fgseaRes[fgseaRes$ES > 0, ][order(fgseaRes[fgseaRes$ES > 0, ]$ES, decreasing = TRUE)[1:10], "pathway"]
topPathwaysDown <- fgseaRes[fgseaRes$ES < 0, ][order(fgseaRes[fgseaRes$ES < 0, ]$ES)[1:10], "pathway"]
topPathways <- unlist(c(topPathwaysUp, rev(topPathwaysDown)))
plotGseaTable(msigdbr_list[topPathways], ranked_gene_set_list$`CENPT_noRT_non-targeting_noRT`, fgseaRes, gseaParam=0.5)
```

Interestingly enough, the PRKDC results seem to be opposite those for GL261 for noRT. Let's take a look at the actual gene log fold changes for inteferon gamma and inflammatory responses.

```{r}
# Load the LFCs from GL261
gl261_lfcs <- read.table("/raleighlab/data1/czou/gbm_perturb/gbm_perturb_gl261_clean_outputs/deseq/GL261_integrated_20230705_ced_noRTNormalized_all/CED_Prkdc_noRT_non-targeting_noRT.csv")
gl261_lfcs$feature <- toupper(gl261_lfcs$feature)

# Load the LFCs from GBM43
gbm43_lfcs <- data.list$`PRKDC_noRT_non-targeting_noRT`
gbm43_lfcs$feature <- gsub("GRCh38-", "", gbm43_lfcs$feature)

# Fetch the genes in question
msigdbr_df <- msigdbr(species = "Homo sapiens", category = "H")
msigdbr_list <- split(x = msigdbr_df$gene_symbol, f = msigdbr_df$gs_name)
genes <- msigdbr_list$HALLMARK_INTERFERON_GAMMA_RESPONSE
print(length(genes))

gl261_lfcs <- subset(gl261_lfcs, gl261_lfcs$feature %in% genes)[,c("feature", "log_fc",
                                                                  "padj")]
gbm43_lfcs <- subset(gbm43_lfcs, gbm43_lfcs$feature %in% genes)[,c("feature", "log_fc",
                                                                  "padj")]
combined_df <- merge(gl261_lfcs, gbm43_lfcs, by="feature")
combined_df <- subset(combined_df, !is.na(combined_df$log_fc.x) & 
                        !is.na(combined_df$log_fc.y))
cor(combined_df$log_fc.y, combined_df$log_fc.x)

```

We get that correlation for non-NA LFCs for the INTERFERON_GAMMA_RESPONSE gene set is -0.10423, and for the INFLAMMATORY_RESPONSE is -0.10300. Note that out of the genes that were used to identify the INTERFERON_GAMMA_RESPONSE cluster in the NMF, only CCL5 is shared between the GBM43 and GL261 data.

Run GSEA for gene ontology modules for clusterProfiler

```{r}
bp.ontology.list <- list()
for (name in names(ranked_gene_set_list)) {
  cat("Processing", name)
  gse <- gseGO(
    ranked_gene_set_list[[name]],
    ont = "BP",
    keyType = "ENSEMBL",
    OrgDb = org.Hs.eg.db,
    eps = 1e-300,
    pvalueCutoff = 1.0
  )
  bp.ontology.list[[name]] <- gse
}
saveRDS(bp.ontology.list, file = paste(WORKING_DIR, "bp_ontology_list.rds", sep = "/"))
```

## Plotting with Hallmark ontologies

Let's generate a heatmap that includes all of the outputs across all of the Hallmark gene sets. To do so, we want to convert all of our outputs into a single dataframe.

```{r}
extracted_cols <- lapply(names(fgsea.output.list), function(name) {
  col <- fgsea.output.list[[name]]$ES
  names(col) <- fgsea.output.list[[name]]$pathway
  col
})
combined.df <- do.call(cbind, extracted_cols)
colnames(combined.df) <- names(fgsea.output.list)

ht = Heatmap(combined.df,
        name = "Enrichment Scores across Perturbations and Conditions",
        col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
        cluster_column_slices = FALSE,
        cluster_columns = TRUE,
        width = ncol(combined.df)*unit(4, "mm"),
        height = nrow(combined.df)*unit(4, "mm"),
)
pdf(paste(OUTPUT_DIR, "enrichment_combined_matrix.pdf", sep = "/"),
    width=35,
    height=19,
    useDingbats=FALSE)
draw(ht, heatmap_legend_side = "top", annotation_legend_side = "top")
dev.off()
```

Make a cool bubble plot where the size of the dot corresponds to p-value, the color of the dot corresponds to net enrichment score, and dots that are significant get highlighted with the adjusted p-value. Hierarchically cluster according to effect size. First, prepare the data:

```{r}
combined.df <- bind_rows(fgsea.output.list, .id = "Perturbations")
combined.df$pathway <- gsub("HALLMARK_", "", combined.df$pathway)
combined.df$pathway <- gsub(" ", "", combined.df$pathway)
combined.df$log10pvalue <- -log10(combined.df$pval)
combined.df$Perturbations <- gsub("_non-targeting_noRT", "", combined.df$Perturbations)

combined.df <- combined.df %>%
  group_by(pathway) %>%
  filter(any(pval < 0.05)) %>%
  ungroup()

es.df <- combined.df %>%
  dplyr::select(-pval, -padj, -log2err, -NES, -size, -leadingEdge, -log10pvalue)

es.df <- es.df %>%
  group_by(pathway, Perturbations) %>%
  pivot_wider(names_from = Perturbations, values_from = ES) %>%
  group_by(pathway)

es.df <- as.data.frame(es.df)
rownames(es.df) <- es.df$pathway
es.df <- es.df %>% dplyr::select(-pathway)

# Use this section if you want to split by RT/noRT and cluster
# the columns that way. Note that the rows will still be clustered
# across them RT/noRT

RT.names <- colnames(es.df)[grepl("_RT", colnames(es.df))]
noRT.names <- colnames(es.df)[grepl("_noRT", colnames(es.df))]
RT.df <- es.df[,RT.names]
noRT.df <- es.df[,noRT.names]

col.dist.RT <- dist(t(RT.df), method = "euclidean")
col.hclust.RT <- hclust(col.dist.RT, method = "complete")
col.order.RT <- colnames(RT.df)[order.dendrogram(as.dendrogram(col.hclust.RT))]
col.dist.noRT <- dist(t(noRT.df), method = "euclidean")
col.hclust.noRT <- hclust(col.dist.noRT, method = "complete")
col.order.noRT <- colnames(noRT.df)[order.dendrogram(as.dendrogram(col.hclust.noRT))]
col.order <- c(col.order.noRT, col.order.RT)

row_dist <- dist(es.df, method = "euclidean")
row_hclust <- hclust(row_dist, method = "complete")
row.order <- order.dendrogram(as.dendrogram(row_hclust))

df.ordered <- combined.df %>%
  arrange(match(pathway, rownames(es.df)[row.order]), match(Perturbations, c(col.order.noRT, col.order.RT)))

# Use this section if you just want to cluster across all rows and cols

# row_dist <- dist(es.df, method = "euclidean")
# row_hclust <- hclust(row_dist, method = "complete")
# row_order <- order.dendrogram(as.dendrogram(row_hclust))
# 
# col_dist <- dist(t(es.df), method = "euclidean")
# col_hclust <- hclust(col_dist, method = "complete")
# col.order <- order.dendrogram(as.dendrogram(col_hclust))
# 
# df.ordered <- combined.df %>%
#   arrange(match(pathway, rownames(es.df)[row_order]), match(Perturbations, colnames(es.df)[col.order]))

df.ordered$pathway <- factor(df.ordered$pathway, levels = unique(df.ordered$pathway))
df.ordered$Perturbations <- factor(df.ordered$Perturbations, levels = unique(df.ordered$Perturbations))

# Add in RT fill bar

df.ordered$RT <- ifelse(grepl("_RT", df.ordered$Perturbations), "RT", "noRT")
unique_perturbations <- unique(df.ordered$Perturbations)

rect.df <- data.frame(
  xmin = unique_perturbations,
  xmax = unique_perturbations,
  ymin = rep(max(as.numeric(df.ordered$pathway)) + 1, length(unique_perturbations)),
  ymax = rep(max(as.numeric(df.ordered$pathway)) + 2, length(unique_perturbations)),
  RT = ifelse(df.ordered$RT[match(unique_perturbations, df.ordered$Perturbations)] == "RT", "RT", "noRT")
)
rect.df$numeric_xmin <- as.numeric(as.factor(rect.df$xmin)) - 0.5
rect.df$numeric_xmax <- as.numeric(as.factor(rect.df$xmax)) + 0.5

unique.perturbations <- unique(gsub("_noRT", "", unique_perturbations))
unique.perturbations <- unique(gsub("_RT", "", unique.perturbations))

# Add in screening phenotype annotations

phenoTbl <- read.table('/raleighlab/data1/liuj/crispr_screens/hs_rt_integrated/GBM43_LN18_T98G_zim3_phenotable.txt',sep='\t',header=TRUE,row.names=1)
phenoTbl <- subset(phenoTbl, GBM43.target %in% unique.perturbations)
phenoTbl <- phenoTbl[order(phenoTbl$GBM43.gamma_pval),]
sgAnnot <- data.frame(row.names = unique.perturbations, 
                      gamma = phenoTbl[unique.perturbations,"GBM43.gamma_avg"], 
                      tau = phenoTbl[unique.perturbations,"GBM43.tauRT_avg"], 
                      rho = phenoTbl[unique.perturbations,"GBM43.rhoRT_avg"])
sgAnnot["non-targeting",] <- c(0, 0, 0)
sgAnnot["GRAMD4",] <- c(0, 0, 0)

RT.sgAnnot <- sgAnnot
rownames(RT.sgAnnot) <- paste(rownames(RT.sgAnnot), "_RT", sep = "")

noRT.sgAnnot <- sgAnnot
rownames(noRT.sgAnnot) <- paste(rownames(noRT.sgAnnot), "_noRT", sep = "")

annotation.table <- rbind(RT.sgAnnot, noRT.sgAnnot)
annotation.table <- annotation.table[rownames(annotation.table) != "non-targeting_noRT", ]
annotation.table$Perturbations <- rownames(annotation.table)
annotation.table <- annotation.table %>%
  arrange(match(Perturbations, colnames(es.df)[col.order]))
annotation.table$Perturbations <- factor(annotation.table$Perturbations, levels = unique(annotation.table$Perturbations))

# Add significance layer
df.ordered$Significance <- ifelse(df.ordered$padj < 0.05, "adjp < 0.05", "NA")

# Clean up names
df.ordered$Pathways <- df.ordered$pathway
```

Then make the plot:

```{r}
bubble.plot <- ggplot(df.ordered,
               aes(x = Perturbations)) +
  
  # Add the bubble and outline significance layers
  geom_point(aes(y = Pathways, size = log10pvalue, color = ES), alpha = 0.9) +
  geom_point(data = subset(df.ordered, padj < 0.05), 
            aes(y = pathway, size = log10pvalue, shape = 'adjp < 0.05'), 
            color = "black", fill = NA, alpha = 0.6) + 
  # Add the NA layer
  geom_point(data = subset(df.ordered, is.na(pval) | is.na(padj) | is.na(log10pvalue)), 
            aes(y = Pathways), 
            color = "black", size = 1, alpha = 0.6) +
  scale_size(range = c(2, 7)) +
  scale_color_gradient2(
    low = brewer.pal(n = 11, name = "RdBu")[11],
    mid = "white",
    high = brewer.pal(n = 11, name = "RdBu")[1],
    midpoint = 0,
    na.value = "black",
  ) +
  scale_shape_manual(name = "Significance", 
                   values = c(`adjp < 0.05` = 21),
                   guide = guide_legend(override.aes = list(color = "black", fill = NA))) +
  
  # Add the bar layer
  geom_rect(data = rect.df, aes(xmin = numeric_xmin, xmax = numeric_xmax, ymin = ymin, ymax = ymax, fill = RT), inherit.aes = FALSE) +
  scale_fill_manual(values = c("RT" = "pink", "noRT" = "lightblue")) +

  # Labels
  labs(
    color = "Effect size",
    size = "-Log10 pvalue"
  ) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        panel.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.key.height = unit(0.3, 'cm'),
        axis.line = element_line(colour = "black"),
        legend.key = element_blank())

annotation.plot.theme <- theme(
  panel.background = element_blank(),
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  axis.text.x = element_blank(),
  axis.title.x = element_blank(),
  axis.ticks.x = element_blank(),
  axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0))
)
gamma.plot <- ggplot(annotation.table, aes(x = Perturbations, y = gamma)) +
  geom_col(width = 1, fill = "grey") + annotation.plot.theme
tau.plot <- ggplot(annotation.table, aes(x = Perturbations, y = tau)) +
  geom_col(width = 1, fill = "grey") + annotation.plot.theme
rho.plot <- ggplot(annotation.table, aes(x = Perturbations, y = rho)) +
  geom_col(width = 1, fill = "grey") + annotation.plot.theme

module.dendrogram <- ggtree(as.phylo(row_hclust)) + theme_tree()

# Use this section if not splitting by RT/noRT

# perturb.dendrogram <- ggtree(as.phylo(col_hclust)) + theme_tree() + coord_flip() + scale_x_reverse()
# 
# vertical.plot <- gamma.plot / tau.plot / rho.plot / perturb.dendrogram / bubble.plot + plot_layout(heights = c(0.5, 0.5, 0.5, 0.5, 3))
# dendrogram.vertical.plot <- plot_spacer() / module.dendrogram + plot_layout(heights = c(0.85, 1))

# Use this section if splitting by RT/noRT

perturb.dendrogram.RT <- ggtree(as.phylo(col.hclust.RT)) + theme_tree() + coord_flip() + scale_x_reverse()
perturb.dendrogram.noRT <- ggtree(as.phylo(col.hclust.noRT)) + theme_tree() + coord_flip() + scale_x_reverse()

vertical.plot <- gamma.plot / tau.plot / rho.plot / ((perturb.dendrogram.RT | plot_spacer() | perturb.dendrogram.noRT) + plot_layout(widths = c(0.33, -0.02, 0.36))) / bubble.plot + plot_layout(heights = c(0.5, 0.5, 0.5, 0.5, 3))
dendrogram.vertical.plot <- plot_spacer() / module.dendrogram + plot_layout(heights = c(0.85, 1))
combined.plot <- dendrogram.vertical.plot | vertical.plot

combined.plot <- combined.plot + plot_layout(widths = c(0.2, 0.8)) + plot_annotation(
  title = "Enrichment of Hallmark pathways across perturbations",
  subtitle = "GBM43 CED RT/noRT"
)
ggsave(paste(WORKING_DIR, "enrichment_bubble_plot_fgsea_ensembl.pdf", sep = "/"),
       combined.plot, height = 12, width = 18, device = pdf)
```

## Run GSEA with Reactome

```{r}
WORKING_DIR <- "/raleighlab/data1/czou/gbm_perturb/gbm_perturb_gbm43_explore_outputs/gsea/noRTNormalized/reactome"
```

To better run this, we want to filter the DESeq outputs for each perturbation. According to the [DESeq2 documentation](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#pvaluesNA), rows that don't have adjusted p-values or regular p-values are those that are determined to be one of the following:

-   Genes with low normalized mean count by independent filtering

-   Genes with extreme outlier mean counts by Cook's distance

-   Genes that have zeroes across the board

```{r}
processed.deseq.tables <- list()
for (name in names(data.list.ensembl)) {
  deseq_table <- data.list.ensembl[[name]]
  deseq_table <- deseq_table[!is.na(deseq_table$pvalue), ]
  deseq_table <- deseq_table[!is.na(deseq_table$padj), ]
  processed.deseq.tables[[name]] <- deseq_table
}
```

### Load Reactome data

Offline, we can get the Reactome hierarchy information. We also figured out who the top level parents were. The top-level is way too nonspecific—think "Digestion," so let's go one level down in granularity.

```{r}
hierarchy.data <- read.table(paste(WORKING_DIR, "reactome_2023_hierarchy.txt", sep = "/"),
                             sep = "\t", header = FALSE, stringsAsFactors = FALSE,
                             col.names = c("Parent", "Child"))

top.level.parents.path <- paste(WORKING_DIR, "top_level_parents.txt", sep = "/")
top.level.parents.ids <- readLines(top.level.parents.path)

# Filter out all non-human parents
top.level.parents.ids <- top.level.parents.ids[grep("-HSA-", top.level.parents.ids)]

# Start finding children to the depth required
depth1.children.ids <- subset(hierarchy.data, Parent %in% top.level.parents.ids)$Child
depth2.children.ids <- subset(hierarchy.data, Parent %in% depth1.children.ids)$Child

# Map these children to terms
path.to.name.map <- as.list(reactome.db::reactomePATHID2NAME)
depth2.children.names <- unlist(path.to.name.map[depth2.children.ids])
depth2.children.names <- gsub("Homo sapiens: ", "", depth2.children.names)

depth1.children.names <- unlist(path.to.name.map[depth1.children.ids])
depth1.children.names <- gsub("Homo sapiens: ", "", depth1.children.names)

write.table(depth1.children.names, paste(WORKING_DIR, "reactome_2023_depth1_children.txt", sep = "/"))

terms <- depth1.children.names
```

Load all of the ENSEMBL to pathway information and construct a list that maps ENSEMBL pathway name to the genes it represents.

```{r}
pathway.to.ensembl.data <- read.table(paste(WORKING_DIR, 
                                   "reactome_2023_ensembl_to_pathway.txt", 
                                   sep = "/"), 
                             sep = "\t", header = FALSE, 
                             stringsAsFactors = FALSE, comment.char = "")
colnames(pathway.to.ensembl.data) <- c("ensembl", 
                                       "rtag", "url", "pathway", "annot", "species")
pathway.to.ensembl.data <- subset(pathway.to.ensembl.data, species == "Homo sapiens")
pathway.to.ensembl.data <- subset(pathway.to.ensembl.data, pathway %in% terms)
pathway_to_ensembl <- split(pathway.to.ensembl.data$ensembl, pathway.to.ensembl.data$pathway)
```

### Run Reactome!

Generate an ordered list from the processed DESeq2 tables

```{r}
ranked_gene_set_list <- list()
for (name in names(processed.deseq.tables)) {
  deseq_table <- processed.deseq.tables[[name]]
  # Group by unique Ensembl ID and average
  deseq_table <- deseq_table %>%
    group_by(ensembl) %>%
    summarize(log_fc = mean(log_fc))
  deseq_table <- deseq_table %>% mutate(rank = rank(log_fc,  ties.method = "random"))
  deseq_table <- deseq_table[order(-deseq_table$rank),] # Rank deterministically
  
  # Generate a ranked list
  gene_list <- deseq_table$log_fc
  gene_names <- deseq_table$ensembl
  names(gene_list) <- gene_names
  ranked_gene_set_list[[name]] <- gene_list
}
```

Then, we can run GSEA using `fgsea`.

```{r}
set.seed(1) # required for deterministic performance
fgsea.output.list <- list()
for (name in names(ranked_gene_set_list)) {
  genes <- names(ranked_gene_set_list[[name]])
  pathways <- pathway_to_ensembl
  gsea.results <- fgsea(pathways = pathway_to_ensembl, stats = ranked_gene_set_list[[name]],
                        maxSize = 500, eps = 0.0) # allow arbitrarily low p-values
  fgsea.output.list[[name]] <- gsea.results
}
saveRDS(fgsea.output.list, paste(WORKING_DIR, "fgsea_ensembl_reactome_list.rds", sep = "/"))
```

After that, plot the results in the same way that we plotted the others. Find the union of the top 1% of pathways across all perturbations:

```{r}
combined.df <- bind_rows(fgsea.output.list, .id = "Perturbations")
combined.df$log10pvalue <- -log10(combined.df$pval)
combined.df$Perturbations <- gsub("_non-targeting_noRT", "", combined.df$Perturbations)

# Filter out any pathways that have no significance across any perturbation
combined.df <- combined.df %>%
  group_by(pathway) %>%
  filter(any(pval < 0.05)) %>%
  ungroup()

# Filter out any pathways that don't have any perturbation where they match more than 5 
combined.df <- combined.df %>%
  group_by(pathway) %>%
  filter(any(size >= 5)) %>%
  ungroup()

# # Find the number of pathways in the top 1% for each perturbation
# combined.df <- combined.df %>%
#   group_by(Perturbations) %>%
#   mutate(total_count = ceiling(n() * 0.01))
# 
# # Slice all of the perturbations to that number of pathways
# top.pathways <- combined.df %>%
#   group_by(Perturbations) %>%
#   arrange(desc(abs(ES))) %>%
#   filter(row_number() <= total_count) %>% 
#   ungroup() %>%
#   distinct(pathway) %>%
#   pull(pathway)
```

Plot a reduced heatmap that can tell us what the enrichment scores look like:

```{r}
extracted_cols <- lapply(names(fgsea.output.list), function(name) {
  col <- fgsea.output.list[[name]]$ES
  names(col) <- fgsea.output.list[[name]]$pathway
  col
})
heatmap.df <- do.call(cbind, extracted_cols)
colnames(heatmap.df) <- names(fgsea.output.list)
# heatmap.df <- heatmap.df[top.pathways, ]

colnames(heatmap.df) <- gsub("_non-targeting_noRT", "", colnames(heatmap.df))

ht = Heatmap(heatmap.df,
        name = "Enrichment Scores across Perturbations and Conditions",
        col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
        cluster_column_slices = FALSE,
        cluster_columns = TRUE,
        width = ncol(heatmap.df)*unit(2, "mm"),
        height = nrow(heatmap.df)*unit(2, "mm"),
        row_names_gp = gpar(fontsize = 5),
        column_names_gp = gpar(fontsize = 5)
)
pdf(paste(WORKING_DIR, "enrichment_combined_matrix_ensembl.pdf", sep = "/"),
    width=20,
    height=50,
    useDingbats=FALSE)
draw(ht, heatmap_legend_side = "top", annotation_legend_side = "top")
dev.off()
```

Then the preparation for the bubble plot:

```{r}
combined.df <- bind_rows(fgsea.output.list, .id = "Perturbations")
combined.df$log10pvalue <- -log10(combined.df$pval)
combined.df$Perturbations <- gsub("_non-targeting_noRT", "", combined.df$Perturbations)

# Filter out any pathways that have no significance across any perturbation
combined.df <- combined.df %>%
  group_by(pathway) %>%
  filter(any(pval < 0.05)) %>%
  ungroup()

# Filter out any pathways that don't have any perturbation where they match more than 5 
combined.df <- combined.df %>%
  group_by(pathway) %>%
  filter(any(size >= 5)) %>%
  ungroup()

# # Find the number of pathways in the top 1% for each perturbation
# combined.df <- combined.df %>%
#   group_by(Perturbations) %>%
#   mutate(total_count = ceiling(n() * 0.01))
# 
# # Slice all of the perturbations to that number of pathways
# top.pathways <- combined.df %>%
#   group_by(Perturbations) %>%
#   arrange(desc(abs(ES))) %>%
#   filter(row_number() <= total_count) %>% 
#   ungroup() %>%
#   distinct(pathway) %>%
#   pull(pathway)

es.df <- combined.df %>%
  dplyr::select(-pval, -padj, -log2err, -NES, -size, -leadingEdge, -log10pvalue)

es.df <- es.df %>%
  group_by(pathway, Perturbations) %>%
  pivot_wider(names_from = Perturbations, values_from = ES) %>%
  group_by(pathway)

es.df <- as.data.frame(es.df)
rownames(es.df) <- es.df$pathway
es.df <- es.df %>% dplyr::select(-pathway)
es.df[is.na(es.df)] <- 0

# Use this section if you want to split by RT/noRT and cluster
# the columns that way. Note that the rows will still be clustered
# across them RT/noRT

# RT.names <- colnames(es.df)[grepl("_RT", colnames(es.df))]
# noRT.names <- colnames(es.df)[grepl("_noRT", colnames(es.df))]
# RT.df <- es.df[,RT.names]
# noRT.df <- es.df[,noRT.names]
# 
# col.dist.RT <- dist(t(RT.df), method = "euclidean")
# col.hclust.RT <- hclust(col.dist.RT, method = "complete")
# col.order.RT <- colnames(RT.df)[order.dendrogram(as.dendrogram(col.hclust.RT))]
# col.dist.noRT <- dist(t(noRT.df), method = "euclidean")
# col.hclust.noRT <- hclust(col.dist.noRT, method = "complete")
# col.order.noRT <- colnames(noRT.df)[order.dendrogram(as.dendrogram(col.hclust.noRT))]
# col.order <- c(col.order.noRT, col.order.RT)
# 
# row_dist <- dist(es.df, method = "euclidean")
# row_hclust <- hclust(row_dist, method = "complete")
# row.order <- order.dendrogram(as.dendrogram(row_hclust))
# 
# df.ordered <- combined.df %>%
#   arrange(match(pathway, rownames(es.df)[row.order]), match(Perturbations, c(col.order.noRT, col.order.RT)))

# Use this section if you just want to cluster across all rows and cols

row_dist <- dist(es.df, method = "euclidean")
row_hclust <- hclust(row_dist, method = "complete")
row_order <- order.dendrogram(as.dendrogram(row_hclust))

col_dist <- dist(t(es.df), method = "euclidean")
col_hclust <- hclust(col_dist, method = "complete")
col.order <- order.dendrogram(as.dendrogram(col_hclust))

df.ordered <- combined.df %>%
  arrange(match(pathway, rownames(es.df)[row_order]), match(Perturbations, colnames(es.df)[col.order]))

df.ordered$pathway <- factor(df.ordered$pathway, levels = unique(df.ordered$pathway))
df.ordered$Perturbations <- factor(df.ordered$Perturbations, levels = unique(df.ordered$Perturbations))

# Add in RT fill bar

df.ordered$RT <- ifelse(grepl("_RT", df.ordered$Perturbations), "RT", "noRT")
unique_perturbations <- unique(df.ordered$Perturbations)

rect.df <- data.frame(
  xmin = unique_perturbations,
  xmax = unique_perturbations,
  ymin = rep(max(as.numeric(df.ordered$pathway)) + 1, length(unique_perturbations)),
  ymax = rep(max(as.numeric(df.ordered$pathway)) + 2, length(unique_perturbations)),
  RT = ifelse(df.ordered$RT[match(unique_perturbations, df.ordered$Perturbations)] == "RT", "RT", "noRT")
)
rect.df$numeric_xmin <- as.numeric(as.factor(rect.df$xmin)) - 0.5
rect.df$numeric_xmax <- as.numeric(as.factor(rect.df$xmax)) + 0.5

unique.perturbations <- unique(gsub("_noRT", "", unique_perturbations))
unique.perturbations <- unique(gsub("_RT", "", unique.perturbations))

# Add in screening phenotype annotations

phenoTbl <- read.table('/raleighlab/data1/liuj/crispr_screens/hs_rt_integrated/GBM43_LN18_T98G_zim3_phenotable.txt',sep='\t',header=TRUE,row.names=1)
phenoTbl <- subset(phenoTbl, GBM43.target %in% unique.perturbations)
phenoTbl <- phenoTbl[order(phenoTbl$GBM43.gamma_pval),]
sgAnnot <- data.frame(row.names = unique.perturbations, 
                      gamma = phenoTbl[unique.perturbations,"GBM43.gamma_avg"], 
                      tau = phenoTbl[unique.perturbations,"GBM43.tauRT_avg"], 
                      rho = phenoTbl[unique.perturbations,"GBM43.rhoRT_avg"])
sgAnnot["non-targeting",] <- c(0, 0, 0)
sgAnnot["GRAMD4",] <- c(0, 0, 0)

RT.sgAnnot <- sgAnnot
rownames(RT.sgAnnot) <- paste(rownames(RT.sgAnnot), "_RT", sep = "")

noRT.sgAnnot <- sgAnnot
rownames(noRT.sgAnnot) <- paste(rownames(noRT.sgAnnot), "_noRT", sep = "")

annotation.table <- rbind(RT.sgAnnot, noRT.sgAnnot)
annotation.table <- annotation.table[rownames(annotation.table) != "non-targeting_noRT", ]
annotation.table$Perturbations <- rownames(annotation.table)
annotation.table <- annotation.table %>%
  arrange(match(Perturbations, colnames(es.df)[col.order]))
annotation.table$Perturbations <- factor(annotation.table$Perturbations, levels = unique(annotation.table$Perturbations))

# Add significance layer
df.ordered$Significance <- ifelse(df.ordered$padj < 0.05, "adjp < 0.05", "NA")

# Clean up names
df.ordered$Pathways <- df.ordered$pathway
```
